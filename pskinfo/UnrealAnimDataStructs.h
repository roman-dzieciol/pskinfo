/*======================================================================

	Animation file data structures 
	Copyright 1997-2003 Epic Games, Inc. All Rights Reserved.

========================================================================*/
#pragma once
#pragma pack(push,4)

#include "PSKTypes.h"
#include "PSKArchive.h"

// Stub to outline FQuat, which we won't fully define here...
class FQuat
{
public:
	FLOAT X,Y,Z,W;

	friend void operator << ( PSKArchive& A, FQuat& D )		
	{ 
		A << D.X;
		A << D.Y;
		A << D.Z;
		A << D.W;
	}
};

// 
class FVector
{
public:
	FLOAT X,Y,Z;

	friend void operator << ( PSKArchive& A, FVector& D )		
	{ 
		A << D.X;
		A << D.Y;
		A << D.Z;
	}
};


// A bone: an orientation, and a position, all relative to their parent.
struct VJointPos
{
	FQuat   	Orientation;  //
	FVector		Position;     //  

	FLOAT       Length;       //  For collision testing / debugging drawing.  (unused)
	FLOAT       XSize;
	FLOAT       YSize;
	FLOAT       ZSize;


	friend void operator << ( PSKArchive& A, VJointPos& D )		
	{ 
		A << D.Orientation;
		A << D.Position;

		A << D.Length;
		A << D.XSize;
		A << D.YSize;
		A << D.ZSize;
	}
};


// Binary animation info format - used to organize raw animation keys into FAnimSeqs on rebuild
// Similar to MotionChunkDigestInfo..
struct AnimInfoBinary
{
	ANSICHAR Name[64];     // Animation's name
	ANSICHAR Group[64];    // Animation's group name	

	INT TotalBones;           // TotalBones * NumRawFrames is number of animation keys to digest.

	INT RootInclude;          // 0 none 1 included 	(unused)
	INT KeyCompressionStyle;  // Reserved: variants in tradeoffs for compression.
	INT KeyQuotum;            // Max key quotum for compression	
	FLOAT KeyReduction;       // desired 
	FLOAT TrackTime;          // explicit - can be overridden by the animation rate
	FLOAT AnimRate;           // frames per second.
	INT StartBone;            // - Reserved: for partial animations (unused)
	INT FirstRawFrame;        //
	INT NumRawFrames;         // NumRawFrames and AnimRate dictate tracktime...

	friend void operator << ( PSKArchive& A, AnimInfoBinary& D )		
	{ 
		A.Serialize(&D.Name, 64);
		A.Serialize(&D.Group, 64);

		A << D.TotalBones;

		A << D.RootInclude;
		A << D.KeyCompressionStyle;
		A << D.KeyQuotum;
		A << D.KeyReduction;
		A << D.TrackTime;
		A << D.AnimRate;
		A << D.StartBone;
		A << D.FirstRawFrame;
		A << D.NumRawFrames;
	}
};


// File header structure. 
struct VChunkHeader
{
	ANSICHAR    ChunkID[20];  // String ID of up to 19 chars (usually zero-terminated)
	INT			TypeFlag;     // Flags/reserved
   	INT         DataSize;     // Size per struct following;
	INT         DataCount;    // Number of structs/

	friend void operator << ( PSKArchive& A, VChunkHeader& D )		
	{ 
		A.Serialize(&D.ChunkID, 20);

		A << D.TypeFlag;
		A << D.DataSize;
		A << D.DataCount;
	}
};

// Raw data material.
struct VMaterial
{
	ANSICHAR    MaterialName[64];
	INT			TextureIndex;  // Texture index ('multiskin index')
	DWORD		PolyFlags;     // ALL poly's with THIS material will have this flag.
	INT	        AuxMaterial;   // Reserved: index into another material, eg. detailtexture/shininess/whatever.
	DWORD		AuxFlags;      // Reserved: auxiliary flags 
	INT			LodBias;       // Material-specific lod bias (unused)
	INT			LodStyle;      // Material-specific lod style (unused)

	friend void operator << ( PSKArchive& A, VMaterial& D )		
	{ 
		A.Serialize(&D.MaterialName, 64);

		A << D.TextureIndex;
		A << D.PolyFlags;
		A << D.AuxMaterial;
		A << D.AuxFlags;
		A << D.LodBias;
		A << D.LodStyle;
	}
};


// Raw data bone.
struct VBone
{
	ANSICHAR    Name[64];     //
	DWORD	    Flags;        // Reserved.
	INT 	    NumChildren;  // Children  (not used.)
	INT         ParentIndex;  // 0/NULL if this is the root bone.  
	VJointPos   BonePos;      // Reference position.

	friend void operator << ( PSKArchive& A, VBone& D )		
	{ 
		A.Serialize(&D.Name, 64);

		A << D.Flags;
		A << D.NumChildren;
		A << D.ParentIndex;
		A << D.BonePos;
	}
};


// Binary bone format to deal with raw animations as generated by various exporters.
struct FNamedBoneBinary
{
	ANSICHAR   Name[64];	// Bone's name
	DWORD      Flags;		// reserved
	INT        NumChildren; //
	INT		   ParentIndex;	// 0/NULL if this is the root bone.  
	VJointPos  BonePos;	    //

	friend void operator << ( PSKArchive& A, FNamedBoneBinary& D )		
	{ 
		A.Serialize(&D.Name, 64);

		A << D.Flags;
		A << D.NumChildren;
		A << D.ParentIndex;
		A << D.BonePos;
	}
};

// Raw data bone influence.
struct VRawBoneInfluence // Just weight, vertex, and Bone, sorted later.
{
	FLOAT Weight;
	INT   PointIndex;
	INT   BoneIndex;

	friend void operator << ( PSKArchive& A, VRawBoneInfluence& D )		
	{ 
		A << D.Weight;
		A << D.PointIndex;
		A << D.BoneIndex;
	}
};

// An animation key.
struct VQuatAnimKey
{
	FVector		Position;           // Relative to parent.
	FQuat       Orientation;        // Relative to parent.
	FLOAT       Time;				// The duration until the next key (end key wraps to first...)

	friend void operator << ( PSKArchive& A, VQuatAnimKey& D )		
	{ 
		A << D.Position;
		A << D.Orientation;
		A << D.Time;
	}
};

// Vertex with texturing info, akin to Hoppe's 'Wedge' concept - import only.
struct VVertex
{
	_WORD	PointIndex;	 // Index into the 3d point table.
	FLOAT   U,V;         // Texture U, V coordinates.
	BYTE    MatIndex;    // At runtime, this one will be implied by the face that's pointing to us.
	BYTE    Reserved;    // Top secret.

	friend void operator << ( PSKArchive& A, VVertex& D )		
	{ 
		A << D.PointIndex;
		A << D.U;
		A << D.V;
		A << D.MatIndex;
		A << D.Reserved;
	}
};

// Points: regular FVectors 
struct VPoint
{	
	FVector			Point; 

	friend void operator << ( PSKArchive& A, VPoint& D )		
	{ 
		A << D.Point;
	}
};

// Textured triangle.
struct VTriangle
{
	_WORD   WedgeIndex[3];	 // Point to three vertices in the vertex list.
	BYTE    MatIndex;	     // Materials can be anything.
	BYTE    AuxMatIndex;     // Second material (unused).
	DWORD   SmoothingGroups; // 32-bit flag for smoothing groups.

	friend void operator << ( PSKArchive& A, VTriangle& D )		
	{ 
		for(int i=0; i<3; ++i) A << D.WedgeIndex[i];

		A << D.MatIndex;
		A << D.AuxMatIndex;
		A << D.SmoothingGroups;
	}
};



#pragma pack(pop)